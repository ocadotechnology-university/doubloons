package com.ocadotechnology.doubloons.security

import cats.effect.Sync
import cats.implicits._

import java.util.Base64
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import java.nio.charset.StandardCharsets
import javax.crypto.spec.PBEKeySpec
import javax.crypto.SecretKeyFactory
import cats.kernel.Eq

trait Cryptography[F[_]] {
  def encrypt(plainText: String, secret: String): F[String]

  def decrypt(
      cipherText: String,
      secret: String
  ): F[Cryptography.DecryptionResult]

}

object Cryptography {

  enum DecryptionResult {
    case Successful(plainText: String)
    case Failed(error: Throwable)
  }

  object DecryptionResult {

    given Eq[DecryptionResult] = Eq.fromUniversalEquals

  }

  def apply[F[_]](implicit ev: Cryptography[F]): Cryptography[F] = ev

  /** Provides implementation of [[Cryptography]]
    *
    * This implementation uses [[javax.crypto]] package to implement basic
    * security.
    *
    * Encryption process:
    *   - Take plaintext and secret as an input (both are strings of arbitrary
    *     length)
    *   - Calculate SHA hash for the secret
    *   - Convert the input string to Array[Byte]
    *   - Instantiate the AES algorithm with the hash as an encryption key
    *   - Perform the encryption
    *   - Encode the encryption output in base64 to make it printable
    *
    * Decryption process:
    *   - Take ciphertext and secret as an input
    *   - Decode the ciphertext from base 64 to Array[Byte]
    *   - Calculate SHA hash for the secret
    *   - Instantiate the AES algorithm with the hash as an encryption key
    *   - Perform the decryption
    *   - Encode the resulting Array[Byte] as plain string using UTF-8
    *
    * Note on AES and SHA usage AES only allows for 64, 128 and 256 bit keys
    * (which corresponds to 8, 16 and 32 characters). To allow arbitrary
    * encryption secret, it's 32 character hash has to be calculated using SHA,
    * so that the AES key length limitation is satisfied.
    *
    * @return
    *   [[Cryptography[F]]] instance using AES algorithm for encryption and
    *   decryption
    */
  def instance[F[_]: Sync]: Cryptography[F] = new Cryptography[F] {
    private val cryptoAlgorithmName = "AES"
    private val charset = StandardCharsets.UTF_8
    private val padding = "/ECB/PKCS5Padding"
    private val transformation = cryptoAlgorithmName + padding
    private val hashingAlgorithmName = "PBKDF2WithHmacSHA1"
    private val hashGenerationCost = 16
    private val hashIterationCount = 1 << hashGenerationCost
    private val AESKeyLength = 256

    private def decodeBase64(input: String): F[Array[Byte]] =
      Sync[F].delay(Base64.getDecoder.decode(input))

    private def encodeBase64String(input: Array[Byte]): F[String] =
      Sync[F].delay(Base64.getEncoder.encodeToString(input))

    private lazy val makeSalt: Array[Byte] = {
      val salt = new Array[Byte](16)
      scala.util.Random.nextBytes(salt)
      salt
    }

    private def hashSecret(secret: String): F[Array[Byte]] = Sync[F].delay {
      val spec = new PBEKeySpec(
        secret.toCharArray(),
        makeSalt,
        hashIterationCount,
        AESKeyLength
      )
      val f = SecretKeyFactory.getInstance(hashingAlgorithmName)
      f.generateSecret(spec).getEncoded()
    }

    private def cipher(
        bytes: Array[Byte],
        hashedSecret: Array[Byte],
        opMode: Int
    ): F[Array[Byte]] = Sync[F].delay {
      val secretKey = new SecretKeySpec(hashedSecret, cryptoAlgorithmName)
      val encipher = Cipher.getInstance(transformation)
      encipher.init(opMode, secretKey)
      encipher.doFinal(bytes)
    }

    private def aesEncrypt(bytes: Array[Byte], secret: String): F[Array[Byte]] =
      hashSecret(secret).flatMap(cipher(bytes, _, Cipher.ENCRYPT_MODE))

    private def aesDecrypt(bytes: Array[Byte], secret: String): F[Array[Byte]] =
      hashSecret(secret).flatMap(cipher(bytes, _, Cipher.DECRYPT_MODE))

    /** Encrypt provided plain text with given secret using AES algorithm
      *
      * @param plainText
      *   string with plain text to be symmetrically encrypted
      * @param secret
      *   password used for encryption
      * @return
      *   base64 encoded string wrapped in effect containing the ciphertext
      */
    override def encrypt(plainText: String, secret: String): F[String] =
      aesEncrypt(plainText.getBytes(charset.name), secret)
        .flatMap(encodeBase64String)

    /** Decrypt ciphertext generated with [[encrypt]] with given secret using
      * AES algorithm
      *
      * @param cipherText
      *   base 64 encoded string generated by [[encrypt]]
      * @param secret
      *   password used for encryption
      * @return
      *   [[DecryptionResult]] object representing either success with plain
      *   text result or failrue
      */
    override def decrypt(
        cipherText: String,
        secret: String
    ): F[DecryptionResult] =
      decodeBase64(cipherText)
        .flatMap(aesDecrypt(_, secret))
        .map(new String(_, charset))
        .map(DecryptionResult.Successful.apply)
        .widen[DecryptionResult]
        .handleError(DecryptionResult.Failed(_))
  }
}
